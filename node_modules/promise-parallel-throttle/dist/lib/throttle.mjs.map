{"version":3,"file":"throttle.mjs","sources":["../../src/throttle.ts"],"sourcesContent":["const DEFAULT_MAX = 5;\r\n\r\nexport interface Result<T> {\r\n    amountDone: number;\r\n    amountStarted: number;\r\n    amountResolved: number;\r\n    amountRejected: number;\r\n    amountNextCheckFalsey: number;\r\n    rejectedIndexes: number[];\r\n    resolvedIndexes: number[];\r\n    nextCheckFalseyIndexes: number[];\r\n    taskResults: T[];\r\n}\r\n\r\nexport interface Options<T> {\r\n    maxInProgress?: number;\r\n    failFast?: boolean;\r\n    progressCallback?: (result: Result<T>) => void;\r\n    nextCheck?: nextTaskCheck<T>;\r\n    ignoreIsFunctionCheck?: boolean;\r\n}\r\n\r\n/**\r\n * Default checker which validates if a next task should begin.\r\n * This can be overwritten to write own checks for example checking the amount\r\n * of used ram and waiting till the ram is low enough for a next task.\r\n *\r\n * It should always resolve with a boolean, either `true` to start a next task\r\n * or `false` to stop executing a new task.\r\n *\r\n * If this method rejects, the error will propagate to the caller\r\n * @param status\r\n * @param tasks\r\n * @returns {Promise}\r\n */\r\nconst defaultNextTaskCheck: nextTaskCheck<unknown> = <T>(status: Result<T>, tasks: Tasks<T>): Promise<boolean> => {\r\n    return Promise.resolve(status.amountStarted < tasks.length);\r\n};\r\n\r\nconst DEFAULT_OPTIONS = {\r\n    maxInProgress: DEFAULT_MAX,\r\n    failFast: false,\r\n    nextCheck: defaultNextTaskCheck,\r\n    ignoreIsFunctionCheck: false\r\n};\r\n\r\nexport type Task<T> = () => Promise<T>;\r\nexport type Tasks<T> = Array<Task<T>>;\r\nexport type nextTaskCheck<T> = (status: Result<T>, tasks: Tasks<T>) => Promise<boolean>;\r\n\r\n/**\r\n * Raw throttle function, which can return extra meta data.\r\n * @param tasks required array of tasks to be executed\r\n * @param options Options object\r\n * @returns {Promise}\r\n */\r\nexport function raw<T>(tasks: Tasks<T>, options?: Options<T>): Promise<Result<T>> {\r\n    return new Promise<Result<T>>((resolve, reject) => {\r\n        const myOptions = Object.assign({}, DEFAULT_OPTIONS, options);\r\n        const result: Result<T> = {\r\n            amountDone: 0,\r\n            amountStarted: 0,\r\n            amountResolved: 0,\r\n            amountRejected: 0,\r\n            amountNextCheckFalsey: 0,\r\n            rejectedIndexes: [],\r\n            resolvedIndexes: [],\r\n            nextCheckFalseyIndexes: [],\r\n            taskResults: []\r\n        };\r\n\r\n        if (tasks.length === 0) {\r\n            return resolve(result);\r\n        }\r\n\r\n        let failedFast = false;\r\n        let currentTaskIndex = 0;\r\n        const executeTask = (index: number) => {\r\n            result.amountStarted++;\r\n\r\n            if (typeof tasks[index] === 'function') {\r\n                tasks[index]().then(\r\n                    taskResult => {\r\n                        result.taskResults[index] = taskResult;\r\n                        result.resolvedIndexes.push(index);\r\n                        result.amountResolved++;\r\n                        taskDone();\r\n                    },\r\n                    error => {\r\n                        result.taskResults[index] = error;\r\n                        result.rejectedIndexes.push(index);\r\n                        result.amountRejected++;\r\n                        if (myOptions.failFast === true) {\r\n                            failedFast = true;\r\n                            return reject(result);\r\n                        }\r\n                        taskDone();\r\n                    }\r\n                );\r\n            } else if (myOptions.ignoreIsFunctionCheck === true) {\r\n                result.taskResults[index] = (tasks[index] as any) as T;\r\n                result.resolvedIndexes.push(index);\r\n                result.amountResolved++;\r\n                taskDone();\r\n            } else {\r\n                failedFast = true;\r\n                return reject(\r\n                    new Error('tasks[' + index + ']: ' + tasks[index] + ', is supposed to be of type function')\r\n                );\r\n            }\r\n        };\r\n\r\n        const taskDone = () => {\r\n            //make sure no more tasks are spawned when we failedFast\r\n            if (failedFast === true) {\r\n                return;\r\n            }\r\n\r\n            result.amountDone++;\r\n            if (typeof (myOptions as Options<T>).progressCallback === 'function') {\r\n                (myOptions as any).progressCallback(result);\r\n            }\r\n            if (result.amountDone === tasks.length) {\r\n                return resolve(result);\r\n            }\r\n            if (currentTaskIndex < tasks.length) {\r\n                nextTask(currentTaskIndex++);\r\n            }\r\n        };\r\n\r\n        const nextTask = (index: number) => {\r\n            //check if we can execute the next task\r\n            myOptions.nextCheck(result, tasks).then(canExecuteNextTask => {\r\n                if (canExecuteNextTask === true) {\r\n                    //execute it\r\n                    executeTask(index);\r\n                } else {\r\n                    result.amountNextCheckFalsey++;\r\n                    result.nextCheckFalseyIndexes.push(index);\r\n                    taskDone();\r\n                }\r\n            }, reject);\r\n        };\r\n\r\n        //spawn the first X task\r\n        for (let i = 0; i < Math.min(myOptions.maxInProgress, tasks.length); i++) {\r\n            nextTask(currentTaskIndex++);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Executes the raw function, but only return the task array\r\n * @param tasks\r\n * @param options\r\n * @returns {Promise}\r\n */\r\nfunction executeRaw<T>(tasks: Tasks<T>, options: Options<T>): Promise<T[]> {\r\n    return new Promise<T[]>((resolve, reject) => {\r\n        raw(tasks, options).then(\r\n            (result: Result<T>) => {\r\n                resolve(result.taskResults);\r\n            },\r\n            (error: Error | Result<T>) => {\r\n                if (error instanceof Error) {\r\n                    reject(error);\r\n                } else {\r\n                    reject(error.taskResults[error.rejectedIndexes[0]]);\r\n                }\r\n            }\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Simply run all the promises after each other, so in synchronous manner\r\n * @param tasks required array of tasks to be executed\r\n * @param options Options object\r\n * @returns {Promise}\r\n */\r\nexport function sync<T>(tasks: Tasks<T>, options?: Options<T>): Promise<T[]> {\r\n    const myOptions = Object.assign({}, {maxInProgress: 1, failFast: true}, options);\r\n    return executeRaw(tasks, myOptions);\r\n}\r\n\r\n/**\r\n * Exposes the same behaviour as Promise.All(), but throttled!\r\n * @param tasks required array of tasks to be executed\r\n * @param options Options object\r\n * @returns {Promise}\r\n */\r\nexport function all<T>(tasks: Tasks<T>, options?: Options<T>): Promise<T[]> {\r\n    const myOptions = Object.assign({}, {failFast: true}, options);\r\n    return executeRaw(tasks, myOptions);\r\n}\r\n"],"names":["DEFAULT_MAX","defaultNextTaskCheck","status","tasks","Promise","resolve","amountStarted","length","DEFAULT_OPTIONS","maxInProgress","failFast","nextCheck","ignoreIsFunctionCheck","raw","options","reject","myOptions","Object","assign","result","amountDone","amountResolved","amountRejected","amountNextCheckFalsey","rejectedIndexes","resolvedIndexes","nextCheckFalseyIndexes","taskResults","failedFast","currentTaskIndex","taskDone","progressCallback","nextTask","index","then","canExecuteNextTask","taskResult","push","error","Error","executeTask","i","Math","min","executeRaw","sync","all"],"mappings":"AAAA,IAAMA,YAAc,EAmCdC,qBAA+C,SAAIC,EAAmBC,GACxE,OAAOC,QAAQC,QAAQH,EAAOI,cAAgBH,EAAMI,SAGlDC,gBAAkB,CACpBC,cAAeT,YACfU,UAAU,EACVC,UAAWV,qBACXW,uBAAuB,YAaXC,IAAOV,EAAiBW,GACpC,OAAO,IAAIV,QAAmB,SAACC,EAASU,GACpC,IAAMC,EAAYC,OAAOC,OAAO,GAAIV,gBAAiBM,GAC/CK,EAAoB,CACtBC,WAAY,EACZd,cAAe,EACfe,eAAgB,EAChBC,eAAgB,EAChBC,sBAAuB,EACvBC,gBAAiB,GACjBC,gBAAiB,GACjBC,uBAAwB,GACxBC,YAAa,IAGjB,GAAqB,IAAjBxB,EAAMI,OACN,OAAOF,EAAQc,GAyEnB,IAtEA,IAAIS,GAAa,EACbC,EAAmB,EAoCjBC,EAAW,WAEb,IAAmB,IAAfF,EAAJ,CAQA,GAJAT,EAAOC,aACmD,mBAA9CJ,EAAyBe,kBAChCf,EAAkBe,iBAAiBZ,GAEpCA,EAAOC,aAAejB,EAAMI,OAC5B,OAAOF,EAAQc,GAEfU,EAAmB1B,EAAMI,QACzByB,EAASH,OAIXG,EAAW,SAACC,GAEdjB,EAAUL,UAAUQ,EAAQhB,GAAO+B,KAAK,SAAAC,IACT,IAAvBA,EAxDQ,SAACF,GAGjB,GAFAd,EAAOb,gBAEqB,mBAAjBH,EAAM8B,GACb9B,EAAM8B,KAASC,KACX,SAAAE,GACIjB,EAAOQ,YAAYM,GAASG,EAC5BjB,EAAOM,gBAAgBY,KAAKJ,GAC5Bd,EAAOE,iBACPS,KAEJ,SAAAQ,GAII,GAHAnB,EAAOQ,YAAYM,GAASK,EAC5BnB,EAAOK,gBAAgBa,KAAKJ,GAC5Bd,EAAOG,kBACoB,IAAvBN,EAAUN,SAEV,OADAkB,GAAa,EACNb,EAAOI,GAElBW,UAGL,CAAA,IAAwC,IAApCd,EAAUJ,sBAOjB,OADAgB,GAAa,EACNb,EACH,IAAIwB,MAAM,SAAWN,EAAQ,MAAQ9B,EAAM8B,GAAS,yCAPxDd,EAAOQ,YAAYM,GAAU9B,EAAM8B,GACnCd,EAAOM,gBAAgBY,KAAKJ,GAC5Bd,EAAOE,iBACPS,KAgCIU,CAAYP,IAEZd,EAAOI,wBACPJ,EAAOO,uBAAuBW,KAAKJ,GACnCH,MAELf,IAIE0B,EAAI,EAAGA,EAAIC,KAAKC,IAAI3B,EAAUP,cAAeN,EAAMI,QAASkC,IACjET,EAASH,OAWrB,SAASe,WAAczC,EAAiBW,GACpC,OAAO,IAAIV,QAAa,SAACC,EAASU,GAC9BF,IAAIV,EAAOW,GAASoB,KAChB,SAACf,GACGd,EAAQc,EAAOQ,cAEnB,SAACW,GACOA,aAAiBC,MACjBxB,EAAOuB,GAEPvB,EAAOuB,EAAMX,YAAYW,EAAMd,gBAAgB,kBAanDqB,KAAQ1C,EAAiBW,GAErC,OAAO8B,WAAWzC,EADAc,OAAOC,OAAO,GAAI,CAACT,cAAe,EAAGC,UAAU,GAAOI,aAU5DgC,IAAO3C,EAAiBW,GAEpC,OAAO8B,WAAWzC,EADAc,OAAOC,OAAO,GAAI,CAACR,UAAU,GAAOI"}
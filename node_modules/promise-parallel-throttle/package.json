{
  "_from": "promise-parallel-throttle",
  "_id": "promise-parallel-throttle@3.1.0",
  "_inBundle": false,
  "_integrity": "sha512-18gafVK+kfabwYl/RolyU7cp62EXtv4RhzRrSqdnlyp48tR8BZUK7fKEeG4nfERJcpkSyD3P50aW/qbZOsUmtw==",
  "_location": "/promise-parallel-throttle",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "promise-parallel-throttle",
    "fetchSpec": "latest",
    "name": "promise-parallel-throttle",
    "raw": "promise-parallel-throttle",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#DEV:/",
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/promise-parallel-throttle/-/promise-parallel-throttle-3.1.0.tgz",
  "_shasum": "0fd4179e944cf94430582e632efde13b8b7bb43d",
  "_shrinkwrap": null,
  "_spec": "promise-parallel-throttle",
  "_where": "C:\\Users\\dklein\\cse\\duolito-client\\Kha\\Tools\\khamake",
  "author": {
    "email": "dirk.jan.wassink@gmail.com",
    "name": "Dirk-Jan Wassink",
    "url": "http://dirkjanwassink.nl"
  },
  "bugs": {
    "url": "https://github.com/DJWassink/Promise-parallel-throttle/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "Run promises in parallel, but throttled",
  "devDependencies": {
    "@types/jest": "^19.2.2",
    "@types/node": "^6.0.46",
    "husky": "^0.14.3",
    "jest": "^19.0.2",
    "lint-staged": "^4.2.3",
    "prettier": "^1.7.2",
    "ts-jest": "^19.0.14",
    "tslint": "^5.1.0",
    "tslint-config-prettier": "^1.5.0",
    "tslint-eslint-rules": "^4.1.1",
    "typescript": "^2.6.1"
  },
  "homepage": "https://github.com/DJWassink/Promise-parallel-throttle#readme",
  "jest": {
    "moduleFileExtensions": [
      "js",
      "ts",
      "tsx"
    ],
    "testRegex": "(/tests/.*|\\.(test|spec))\\.(ts|tsx|js)$",
    "testResultsProcessor": "<rootDir>/node_modules/ts-jest/coverageprocessor.js",
    "transform": {
      ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
    }
  },
  "keywords": [
    "async",
    "parallel",
    "promise",
    "promise.all()",
    "sync",
    "synchronously",
    "throttle"
  ],
  "license": "MIT",
  "lint-staged": {
    "*.{ts,js}": [
      "git add",
      "prettier --write",
      "tslint -c ./tslint.json"
    ]
  },
  "main": "build/throttle.js",
  "name": "promise-parallel-throttle",
  "optionalDependencies": {},
  "prettier": {
    "bracketSpacing": true,
    "jsxBracketSameLine": true,
    "printWidth": 120,
    "singleQuote": true,
    "tabWidth": 4
  },
  "readme": "# Promise-parallel-throttle\n[![Build Status](https://travis-ci.org/DJWassink/Promise-parallel-throttle.svg?branch=master)](https://travis-ci.org/DJWassink/Promise-parallel-throttle)\n\nRun a array of Promises in parallel. Kinda like Promise.all(), but throttled!\n\n## Install \n\n### NPM\n```bash\nnpm i promise-parallel-throttle -S\n```\n\n### Yarn\n```bash\nyarn add promise-parallel-throttle\n```\n\n## Usage\n\n```js\nimport Throttle from 'promise-parallel-throttle';\n\n//Function which should return a Promise\nconst doReq = async (firstName, lastName) => {\n    //Do something async.\n    return firstName + \" \" + lastName;\n}\n\nconst users = [\n    {firstName: \"Irene\", lastName: \"Pullman\"},\n    {firstName: \"Sean\",  lastName: \"Parr\"}\n];\n\n//Queue with functions to be run\nconst queue = users.map(user => () => doReq(user.firstName, user.lastName));\n\n//Default Throttle runs with 5 promises parallel.\nconst formattedNames = await Throttle.all(queue);\n\nconsole.log(formattedNames); //['Irene Pullman', 'Sean Parr']\n```\n\n## API\n### Throttle.all\n`Throttle.all(tasks, options)`\n\nThrottle.all is made to behave exactly like Promise.all but instead of all the tasks running in parallel it runs a maxium amount of tasks in parallel.\nOnly the tasks parameter is required while the [options](#options-object) parameter is optional.\n\n### Throttle.sync\n`Throttle.sync(tasks, options)`\n\nThrottle.sync runs all the tasks synchronously. \nOnce again the tasks array is required, the [options](#options-object) are optional. \nBe aware that this method is simply a wrapper to pass `maxInProgress` with 1. So overwriting this option in the options object would run the tasks again in parallel.\n\n### Throttle.raw\n`Throttle.raw(tasks, options)`\n \n The raw method instead of returning the tasks their results, will return a [result](#result-object--progress-callback) object. \n Useful if you wan't more statistics about the execution of your tasks. Once again the tasks are required while the [options](#options-object) are optional.\n\n#### Option's Object\n|Parameter|Type|Default|Definition|\n|:---|:---|:---|:---|\n|maxInProgress |Integer|5| max amount of parallel threads|\n|failFast |Boolean|true (false for the [raw](#throttleraw) method)| reject after a single error, or keep running|\n|progressCallback |Function|Optional| callback with progress reports|\n|nextCheck |Function|Optional| function which should return a promise, if the promise resolved true the next task is spawn, errors will propagate and should be handled in the calling code|\n\n#### Result object / Progress callback\nThe `progressCallback` and the `Raw` will return a `Result` object with the following properties:\n\n|Property|Type|Start value|Definition|\n|:---|:---|:---|:---|\n|amountDone|Integer|0|amount of tasks which are finished|\n|amountStarted|Integer|0|amount of tasks which started|\n|amountResolved|Integer|0|amount of tasks which successfully resolved|\n|amountRejected|Integer|0|amount of tasks which returned in an error and are aborted|\n|amountNextCheckFalsey|Integer|0|amount of tasks which got a falsey value in the [nextCheck](#nextcheck)|\n|rejectedIndexes|Array|[]|all the indexes in the tasks array where the promise rejected|\n|resolvedIndexes|Array|[]|all the indexes in the tasks array where the promise resolved|\n|nextCheckFalseyIndexes|Array|[]|all the indexes in the tasks array where the [nextCheck](#nextcheck) returned a falsey value|\n|taskResults|Array|[]|array containing the result of every task|\n\n#### nextCheck\nAll the `Throttle` methods have a `nextCheck` method which will be used to verify if a next task is allowed to start. \n\nThe default `nextCheck` is defined like this;\n```js\nconst defaultNextTaskCheck = (status, tasks) => {\n    return new Promise((resolve, reject) => {\n        resolve(status.amountStarted < tasks.length);\n    });\n}\n```\n\nThis function will get a status object as parameter which adheres to the [Result object](#result-object--progress-callback) and it also receives the list of tasks.\nIn the default `nextCheck` we simply check if the amount of started exceeds the amount to be done, if not we are free to start an other task.\n\nThis function can be useful to write your own scheduler based on, for example ram/cpu usage.\nLets say that your tasks use a lot of ram and you don't want to exceed a certain amount.\nYou could then write logic inside a `nextCheck` function which resolves after there is enough ram available to start the next task.\n\nIf a custom implementation decides to reject, the error is propagated and should be handled in the user it's code. If a custom implementation returns a falsey value the task will simply not execute and the next task will be scheduled.\n\n## Example\nCheck out the example's directory, it's heavily documented so it should be easy to follow.\n\nTo run the example, at least Node 8.x.x is required, since it supports native async/await.\n\nSimply run the example with npm:\n```\nnpm run-script names\n```\n\nOr with Yarn:\n```\nyarn names\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/DJWassink/Promise-parallel-throttle.git"
  },
  "scripts": {
    "build": "yarn lint && rm -rf ./build && tsc && npm run declarations",
    "declarations": "tsc --declaration",
    "lint": "tslint -p ./tsconfig.json",
    "lint:fix": "tslint -p ./tsconfig.json --fix",
    "precommit": "lint-staged",
    "prepublish": "npm run build",
    "prettier": "prettier --write \"src/**/*.ts*\"",
    "test": "yarn lint && jest --coverage --no-cache",
    "test:watch": "jest --watch"
  },
  "types": "./build/throttle.d.ts",
  "version": "3.1.0"
}
